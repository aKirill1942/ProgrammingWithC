#include <stdio.h>

/*
    
        ФОРМЫ ПРЕДСТАВЛЕНИЯ АЛГОРИТМОВ

 Задача. Пусть задан набор чисел. Требуется проверить, все ли из них принадлежат заданному сегменту [A, B].
 
 Основные формы представления алгоритмов:
    - Словестный
    - Формульно словестный
    - Блок схемный
    - Псевдокод
    - Языки программирования
 
 Алгоритм (словестный способ):
    1. Выбираем первый элемент набора, переходим к шагу 2.
    2. Если выбранный элемент принадлежит интервалу, переходим к шагу 3, если нет -- к шагу 6.
    3. Все ли элементы проверены? Если "да", то переходим к шагу 5, иначе к шагу 4.
    4. Выбираем следующий элемент и возвращаемся к шагу 2.
    5. Печать сообщения: все элементы принадлежат интервалу. Переход к шагу 7.
    6. Печать сообщения: не все элементы принадлежат интервалу. Переход к шагу 7.
    7. Конец.
 
 Допускаются разные варианты формулировки этого алгоритма.

 (+):
    Удобство. Все четко прописано и понятно, любой человек сможет в нем разобраться с минимумом объяснений. Возможность описать полную последовательность действий на естественном языке.

 (-):
    Нет конкретизации, что означает "принадлежит интервалу". Большой разброс по шагам алгоритма. При меньшем разбросе шагов получаются огромные шаги алгоритма, пропадает структуризация. Отсутствует наглядность вычислительного процесса, так как нет достаточной формализации. Не подходит для ЭВМ.
 
 Алгоритм (формульно  словестный):
 
 (+):
    Возможность описать последовательность действий на естественном языке, дополнив формулаи.
 
 (-):
    Не подходит для ЭВМ. Может содержать сложные формулы и быть доступным не для всех.
 
 Алгоритм (блок-схемный способ):
                                                    |- нет ------------------------------->|
                                                    |                                      |
    ( Начало ) -> / Данные / -> | Процесс | -> < Решение > - да -> { модификация } -> || Предопределенный процесс || ->
    -> / Данные / -> ( Конец )
 
        
                                                  |--------------- нет -> /"Вне отрезка"/ ------------------------->|
                                                  |                                                                 |
    (Начало) -> /N, x, A, B/ -> |i = 1| -> <A <= x[i] <= B> - да -> |i++| -> <i <= N> - нет -> /"На отрезке"/ -> (Конец)
                                                    |                             |
                                                    |<- да -----------------------|
 
 Однако не все алгоритмы могу быть описаны блок-схемами. Данные присутсвуют и в начале программы, и в конце, так как работа с данным, обрабокта данных является ключом в наше время. Отсутствует проверка входных данных, необходимо проверять, чтобы набор данных не был пустым.
 
 (+):
    Наглядно отображаются действия с привлечением минимального количества слов.
 
 (-):
    Не подходит для ЭВМ. Необходимость запоминать блоки.
 
 Алгоритм (псевдокод):

    IF (x[i] < A) OR (x[I] > B) THEN печать сообщения об ошибке и выход из цикла
    ELSE переход к следующему элементу
    IF перебрали все элементы THEN печать сообщения об успехе и выход из цикла
    ELSE проверяем очередной элемент
    END
 
 Алгоритм не является детализированным, однако позволяет программисту понять базовую суть последовательности действий.
 
 (+):
    Использование ключевых слов наряду с естественным языком позволяет проще разрабатывать программный код.
 
 (-):
    Не подходит для ЭВМ.
 
 Алгоритм (языки программирования):
 
 (+):
    Предназначены для ЭВМ.
 
 (-):
    Не похожи на естественные языки, требуется изучение в каждом конкретно случае.
 
 Сложность состоит в необходимость запоминать огромное количество ключевых слов. Однако, как с естественными языками, учить новый язык программирования проще, если какой-то другой уже известен. Также, программирование -- это практика.
 
*/
